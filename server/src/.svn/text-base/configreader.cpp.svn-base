////////////////////////////////////////////////////////////////////////// Textual IRC Server - An open source irc server////////////////////////////////////////////////////////////////////////// Copyright (C) 2010 - 2011 Fallen <F.Fallen45@gmail.com>////////////////////////////////////////////////////////////////////////// This program is free software: you can redistribute it and/or modify// it under the terms of the GNU General Public License as published by// the Free Software Foundation, either version 3 of the License, or// (at your option) any later version.//// This program is distributed in the hope that it will be useful,// but WITHOUT ANY WARRANTY; without even the implied warranty of// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the// GNU General Public License for more details.//// You should have received a copy of the GNU General Public License// along with this program.  If not, see <http://www.gnu.org/licenses/>.////////////////////////////////////////////////////////////////////////#include "configreader.h"#include <cstdio>#include <cstdlib>#include "auxiliar.h"#include <iostream>struct Doc{	Root* root;	Doc()	{		root = new Root;	}};Config::Config(){	m_loaded = false;}Config::~Config(){	m_config.clear();	for (Roots::iterator it = m_roots.begin(); it != m_roots.end(); ++it)		delete *it;	m_roots.clear();}bool Config::load(){	if (m_loaded)		return true;	FILE *f = fopen("config.conf", "r");	if (!f) {		std::clog << "\n[Error - Config::load] (config.conf) Check if it exists or has premissions." << std::endl;		delete f;		return false;	}	if (feof(f)) {		std::clog << "[Error - Config::load] Unepxected end of file." << std::endl;		delete f;		return false;	}	char buffer[512];	Doc* doc = new Doc;	bool nodeStart = false;	std::string p[] = {		"nick",		"ident",		"host"	};	while (fgets(buffer, sizeof(buffer), f)) {		std::string _buff = std::string(buffer);		if (_buff.rfind("\n") != std::string::npos)			_buff.erase(_buff.rfind("\n"));		if (_buff.rfind("\r") != std::string::npos)			_buff.erase(_buff.rfind("\r"));		StringVec splited = splitString(_buff, "=");		if (splited.size() < 2)			continue;		if (splited[0] == "mysql_host")			m_config[C_MYSQL_HOST] = splited[1];		else if (splited[0] == "mysql_port")			m_config[C_MYSQL_PORT] = splited[1];		else if (splited[0] == "mysql_user")			m_config[C_MYSQL_USER] = splited[1];		else if (splited[0] == "mysql_pass")			m_config[C_MYSQL_PASS] = splited[1];		else if (splited[0] == "mysql_db")			m_config[C_MYSQL_DB] = splited[1];		else if (splited[0] == "host")			m_config[C_HOST] = splited[1];		else if (splited[0] == "ports")			m_config[C_PORTS] = splited[1];		else if (splited[0] == "server_name")			m_config[C_SERVER_NAME] = splited[1];		else if (splited[0] == "server_host")			m_config[C_SERVER_HOST] = splited[1];		else if (splited[0] == "max_pending_connections")			m_config[C_MAX_PENDING_CONNECTIONS] = splited[1];		else if (splited[0] == "executable_name")			m_config[C_EXECUTABLE_NAME] = splited[1];		else {			std::string str = _buff;			if (str.substr(0, 1) == "<" && str.rfind(">") != std::string::npos && str.find("/") == std::string::npos) {				std::string _root = str.substr(0, str.rfind(">")+1);				if (doc->root) {					sprintf(doc->root->name, "%s", _root.c_str());					nodeStart = true;				}			}			if (doc->root && str.rfind("</" + std::string(doc->root->name)) != std::string::npos) {				if (nodeStart)					nodeStart = false;			}			if (nodeStart) {				for (size_t i = 0; i < sizeof(p) / sizeof(std::string); ++i) {					if (str.find(p[i]) != std::string::npos) {						size_t s = str.find('"');						if (s == std::string::npos) {							std::clog << "[Warning] No \"something\" for tag " << p[i] << std::endl;							continue;						}						s = str.rfind('"');						if (s == std::string::npos) {							std::clog << "[Warning] No \"something\" for tag " << p[i] << std::endl;							continue;						}						std::string content = str.substr(str.find('"'), str.rfind('"')-str.find('"'));						Node* n = createNode(const_cast<char*>(content.c_str()));						doc->root->insert(&p[i], n);					}				}			}		}	}	m_loaded = true;	return true;}bool Config::reload(){	m_loaded = false;	return load();}std::string Config::getString(int arg){	Config_t p = static_cast<Config_t>(arg);	ConfigMap::const_iterator it = m_config.find(p);	if (it == m_config.end())		return std::string();	return it->second;}Node* Config::getNodeValue(const std::string& nodeName){	for (Roots::const_iterator it = m_roots.begin(); it != m_roots.end(); ++it) {		for (Nodes::const_iterator node = (*it)->beginNodes(); node != (*it)->endNodes(); ++node) {			if (node->first == nodeName)				return node->second;		}	}	return NULL;}int Config::getInt(int arg){	Config_t p = static_cast<Config_t>(arg);	ConfigMap::const_iterator it = m_config.find(p);	if (it == m_config.end())		return 0;	return atoi(it->second.c_str());}